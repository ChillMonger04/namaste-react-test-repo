<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>React Basics</title>
    <link rel="stylesheet" href="styles.css" />
  </head>
  <body>
    <h1 id="headingtop">H1 TOP OF MAIN</h1>
    <div id="main"></div>
    <h1 id="headingbottom">H1 BOTTOM OF MAIN</h1>

    <script type="module" src="script.js"></script>
    <!-- Made it type module so that browser get to know it is not a normal js file -->
  </body>
</html>

<!-- package.json (INSTALL AFTER npm init) is a configuration for our npm, it keeps a track of all the dependencies there versions we are using  -->
<!-- Whereas package.lock.json (INSTALLED AFTER PARCEL) keeps the track of the exact version of dependencies we are using -->
<!-- The node modules -> it contains all the data of npm we have fetched (kind of a database) -->
<!-- Transitive dependency -> it is like we have parcel as a dependency, it will further have its own dependencies -->

<!-- There are 2 types of dependencies that we can install -> Dev and Normal
Dev is mostly used for development production builds and Normal are used for general builds
We installed parcel as a dev dependency (-D)

CARET and TILDE are used in version to automatically update if there is a change in our dependency version -->

<!-- As soon as we do some changes in our code and save it Parcel reloads the page the shows the updated version
this is know as HMR. Parcel does the following things
    HMR -> Hot Module Replacement
    File Watching Algorithm
    Caching Files -> For faster builds
    Image Optimization
    Minification and Bundling
    Consistent Hashing 
    Differential Bundling -> Supports older browsers
    Error Handling
    Tree Shaking -> removes unused functions and code for you
    Different dev and prod builds -->

<!-- For production ready build we do npx parcel build index.html -> it creates a dist folder and
this folder contains the minified and bundled files of our dev build files -->

<!-- Browsers-List is also an npm package and is very important we need to add the list of browsers we want our app to be seen on
For this we do changes in the package.json file (open browserslist in browser) -->

<!-- PROPS is similar to passing arguments to a function -->
<!-- Sending props and receiving them is know as props drilling
 we can destructure it also as we receive (DESTRUCTURE ON THE FLY) -> {resName, cuisine, ratings} = resData.data -->

<!-- While creating components we can use either of the extension of .jsx or .js doesn't matter
There are two types of Import/Export 
  Named Export -> export const Component
  Named Import -> import {Component} from 'path'

  Default Export -> export default Component
  Default Import -> import Component from 'path' -->

<!-- React Hook are normal JS Utility functions
Whenever there is a change in the state, React re-render the component
Array destructing is used in useState hook -->

<!-- SUPER IMP
We needed the second function in useState hook to trigger the Diff Algorithm
React creates a virtual DOM of the state variable and whenever the state variable changes is updated
React then compares the new virtual DOM with the old virtual DOM and updates only the necessary parts of the DOM
This way, it makes the application more efficient and faster to render -->

<!-- Optional Chaining (?.) -->

<!-- Optional chaining is used to make our code more readable and error-proof
For example, instead of writing if(resData && resData.data && resData.data.results) we can write resData?.data?.results -->
<!-- This operator accesses the object's property or calls a function. If the object
accessed or function called using this operator is undefined or null, the
expression short circuits and evaluates to undefined instead of throwing an
error. -->
